"""Internal module for Python 2 backwards compatibility."""
from __future__ import unicode_literals
from future import standard_library
standard_library.install_aliases()
from builtins import chr
from builtins import str
from past.builtins import basestring
import sys


if sys.version_info[0] < 3:
    from urllib.parse import unquote
    from urllib.parse import parse_qs, urlparse
    
    from string import letters as ascii_letters
    from queue import Queue
    try:
        from io import StringIO as BytesIO
    except ImportError:
        from io import StringIO as BytesIO

    # special unicode handling for python2 to avoid UnicodeDecodeError
    def safe_unicode(obj, *args):
        """ return the unicode representation of obj """
        try:
            return str(obj, *args)
        except UnicodeDecodeError:
            # obj is byte string
            ascii_text = str(obj).encode('string_escape')
            return str(ascii_text)

    def iteritems(x):
        return iter(list(x.items()))

    def iterkeys(x):
        return iter(list(x.keys()))

    def itervalues(x):
        return iter(list(x.values()))

    def nativestr(x):
        return x if isinstance(x, str) else x.encode('utf-8', 'replace')

    def u(x):
        return x.decode()

    def b(x):
        return x

    def next(x):
        return x.__next__()

    def byte_to_chr(x):
        return x

    chr = chr
    xrange = xrange
    basestring = basestring
    str = str
    bytes = str
    long = int
else:
    from urllib.parse import parse_qs, unquote, urlparse
    from io import BytesIO
    from string import ascii_letters
    from queue import Queue

    def iteritems(x):
        return iter(list(x.items()))

    def iterkeys(x):
        return iter(list(x.keys()))

    def itervalues(x):
        return iter(list(x.values()))

    def byte_to_chr(x):
        return chr(x)

    def nativestr(x):
        return x if isinstance(x, str) else x.decode('utf-8', 'replace')

    def u(x):
        return x

    def b(x):
        return x.encode('latin-1') if not isinstance(x, bytes) else x

    next = next
    chr = chr
    imap = map
    izip = zip
    xrange = range
    basestring = str
    str = str
    safe_unicode = str
    bytes = bytes
    long = int

try:  # Python 3
    from queue import LifoQueue, Empty, Full
except ImportError:
    from queue import Empty, Full
    try:  # Python 2.6 - 2.7
        from queue import LifoQueue
    except ImportError:  # Python 2.5
        from queue import Queue
        # From the Python 2.7 lib. Python 2.5 already extracted the core
        # methods to aid implementating different queue organisations.

        class LifoQueue(Queue):
            "Override queue methods to implement a last-in first-out queue."

            def _init(self, maxsize):
                self.maxsize = maxsize
                self.queue = []

            def _qsize(self, len=len):
                return len(self.queue)

            def _put(self, item):
                self.queue.append(item)

            def _get(self):
                return self.queue.pop()
